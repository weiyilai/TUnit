using System.Collections.Generic;
using System.Linq;
using TUnit.Mocks.SourceGenerator.Models;

namespace TUnit.Mocks.SourceGenerator.Builders;

/// <summary>
/// Generates a single _MockMembers.g.cs file per mocked type, containing:
/// 1. Extension methods on Mock&lt;T&gt; for each method
/// 2. Extension properties on Mock&lt;T&gt; for each property (C# 14 extension blocks)
/// 3. Unified sealed classes per qualifying method (with BOTH setup and verify methods)
/// </summary>
internal static class MockMembersBuilder
{
    private const int MaxTypedParams = 8;

    private static readonly HashSet<string> MockMemberNames = new(System.StringComparer.Ordinal)
    {
        "Object", "Engine", "Behavior", "Invocations", "DefaultValueProvider",
        "SetupAllProperties", "Reset", "VerifyAll", "VerifyNoOtherCalls",
        "GetAutoMock", "GetDiagnostics", "SetState", "InState",
        "GetHashCode", "GetType", "ToString", "Equals"
    };

    public static string Build(MockTypeModel model)
    {
        var writer = new CodeWriter();
        var safeName = MockImplBuilder.GetSafeName(model.FullyQualifiedName);
        var hasEvents = model.Events.Length > 0;

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();

        using (writer.Block("namespace TUnit.Mocks.Generated"))
        {
            // Extension methods class
            using (writer.Block($"public static class {safeName}_MockMemberExtensions"))
            {
                bool firstMember = true;

                // Methods
                foreach (var method in model.Methods)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GenerateMemberMethod(writer, method, model, safeName);
                }

                // Properties -- extension properties via C# 14 extension blocks
                var memberProps = model.Properties
                    .Where(p => !p.IsIndexer && (p.HasGetter || p.HasSetter))
                    .ToList();
                if (memberProps.Count > 0)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GeneratePropertyExtensionBlock(writer, memberProps, model, safeName);
                }

                // Raise extension methods for events
                if (model.Events.Length > 0)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GenerateRaiseExtensionMethods(writer, model);
                }
            }

            // Generate unified sealed classes for qualifying methods
            foreach (var method in model.Methods)
            {
                if (!ShouldGenerateTypedWrapper(method, hasEvents)) continue;
                writer.AppendLine();
                GenerateUnifiedSealedClass(writer, method, safeName, model.Events);
            }
        }

        return writer.ToString();
    }

    private static bool ShouldGenerateTypedWrapper(MockMemberModel method, bool hasEvents)
    {
        if (method.IsGenericMethod) return false;

        var nonOutParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();
        if (nonOutParams.Count == 0)
        {
            var hasOutRefParams = method.Parameters.Any(p => p.Direction == ParameterDirection.Out || p.Direction == ParameterDirection.Ref);
            return hasEvents || hasOutRefParams;
        }
        return nonOutParams.Count <= MaxTypedParams;
    }

    private static string GetWrapperName(string safeName, MockMemberModel method)
        => $"{safeName}_{method.Name}_M{method.MemberId}_MockCall";

    private static string GetSafeMemberName(string name)
        => MockMemberNames.Contains(name) ? name + "_" : name;

    private static void GenerateUnifiedSealedClass(CodeWriter writer, MockMemberModel method, string safeName,
        EquatableArray<MockEventModel> events)
    {
        var setupReturnType = method.IsAsync && !method.IsVoid
            ? method.UnwrappedReturnType
            : method.ReturnType;

        var wrapperName = GetWrapperName(safeName, method);
        var nonOutParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();

        if (method.IsVoid)
        {
            GenerateVoidUnifiedClass(writer, wrapperName, nonOutParams, events, method.Parameters);
        }
        else
        {
            GenerateReturnUnifiedClass(writer, wrapperName, nonOutParams, setupReturnType, events, method.Parameters);
        }
    }

    private static void GenerateReturnUnifiedClass(CodeWriter writer, string wrapperName,
        List<MockParameterModel> nonOutParams, string returnType, EquatableArray<MockEventModel> events,
        EquatableArray<MockParameterModel> allParameters)
    {
        var builderType = $"global::TUnit.Mocks.Setup.MethodSetupBuilder<{returnType}>";
        var hasOutRef = allParameters.Any(p => p.Direction == ParameterDirection.Out || p.Direction == ParameterDirection.Ref);

        writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        using (writer.Block($"public sealed class {wrapperName} : global::TUnit.Mocks.Verification.ICallVerification"))
        {
            // Fields
            writer.AppendLine("private readonly global::TUnit.Mocks.IMockEngineAccess _engine;");
            writer.AppendLine("private readonly int _memberId;");
            writer.AppendLine("private readonly string _memberName;");
            writer.AppendLine("private readonly global::TUnit.Mocks.Arguments.IArgumentMatcher[] _matchers;");
            writer.AppendLine($"private readonly global::System.Lazy<{builderType}> _lazyBuilder;");
            writer.AppendLine();

            // Constructor — lazy registration via Lazy<T> for thread safety
            writer.AppendLine($"internal {wrapperName}(global::TUnit.Mocks.IMockEngineAccess engine, int memberId, string memberName, global::TUnit.Mocks.Arguments.IArgumentMatcher[] matchers)");
            using (writer.Block())
            {
                writer.AppendLine("_engine = engine;");
                writer.AppendLine("_memberId = memberId;");
                writer.AppendLine("_memberName = memberName;");
                writer.AppendLine("_matchers = matchers;");
                using (writer.Block($"_lazyBuilder = new global::System.Lazy<{builderType}>(() =>"))
                {
                    writer.AppendLine("var setup = new global::TUnit.Mocks.Setup.MethodSetup(_memberId, _matchers, _memberName);");
                    writer.AppendLine("_engine.AddSetup(setup);");
                    writer.AppendLine($"return new {builderType}(setup);");
                }
                writer.AppendLine(");");
            }

            writer.AppendLine();

            // EnsureSetup method
            writer.AppendLine($"private {builderType} EnsureSetup() => _lazyBuilder.Value;");

            writer.AppendLine();

            // Public self-returning setup methods
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Returns({returnType} value) {{ EnsureSetup().Returns(value); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Returns(global::System.Func<{returnType}> factory) {{ EnsureSetup().Returns(factory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} ReturnsSequentially(params {returnType}[] values) {{ EnsureSetup().ReturnsSequentially(values); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws<TException>() where TException : global::System.Exception, new() {{ EnsureSetup().Throws<TException>(); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Exception exception) {{ EnsureSetup().Throws(exception); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action callback) {{ EnsureSetup().Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action<object?[]> callback) {{ EnsureSetup().Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Returns(global::System.Func<object?[], {returnType}> factory) {{ EnsureSetup().Returns(factory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Func<object?[], global::System.Exception> exceptionFactory) {{ EnsureSetup().Throws(exceptionFactory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Raises(string eventName, object? args = null) {{ EnsureSetup().Raises(eventName, args); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            if (hasOutRef)
                writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
            writer.AppendLine($"public {wrapperName} SetsOutParameter(int paramIndex, object? value) {{ EnsureSetup().SetsOutParameter(paramIndex, value); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} TransitionsTo(string stateName) {{ EnsureSetup().TransitionsTo(stateName); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Then() {{ EnsureSetup().Then(); return this; }}");

            // Typed parameter overloads (only for methods with typed params)
            if (nonOutParams.Count >= 1)
            {
                writer.AppendLine();
                GenerateTypedReturnsOverload(writer, nonOutParams, returnType, wrapperName);
                writer.AppendLine();
                GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName);
                writer.AppendLine();
                GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName);
            }

            // Typed out/ref parameter setters
            if (hasOutRef)
            {
                writer.AppendLine();
                GenerateTypedOutRefMethods(writer, allParameters, wrapperName);
            }

            // Typed event raises
            if (events.Length > 0)
            {
                writer.AppendLine();
                GenerateTypedEventRaises(writer, events, wrapperName);
            }

            // Verify methods (ICallVerification implementation)
            writer.AppendLine();
            writer.AppendLine("// ICallVerification");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled() => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled();");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(global::TUnit.Mocks.Times times) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(times);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(global::TUnit.Mocks.Times times, string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(times, message);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(message);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasNeverCalled() => _engine.CreateVerification(_memberId, _memberName, _matchers).WasNeverCalled();");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasNeverCalled(string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasNeverCalled(message);");
        }
    }

    private static void GenerateVoidUnifiedClass(CodeWriter writer, string wrapperName,
        List<MockParameterModel> nonOutParams, EquatableArray<MockEventModel> events,
        EquatableArray<MockParameterModel> allParameters)
    {
        var builderType = "global::TUnit.Mocks.Setup.VoidMethodSetupBuilder";
        var hasOutRef = allParameters.Any(p => p.Direction == ParameterDirection.Out || p.Direction == ParameterDirection.Ref);

        writer.AppendLine($"[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        using (writer.Block($"public sealed class {wrapperName} : global::TUnit.Mocks.Verification.ICallVerification"))
        {
            // Fields
            writer.AppendLine("private readonly global::TUnit.Mocks.IMockEngineAccess _engine;");
            writer.AppendLine("private readonly int _memberId;");
            writer.AppendLine("private readonly string _memberName;");
            writer.AppendLine("private readonly global::TUnit.Mocks.Arguments.IArgumentMatcher[] _matchers;");
            writer.AppendLine($"private readonly global::System.Lazy<{builderType}> _lazyBuilder;");
            writer.AppendLine();

            // Constructor — Lazy<T> for thread safety, eagerly materialized because void methods
            // are commonly used without chaining (e.g., mock.Log(Arg.Any<string>()) in strict mode).
            writer.AppendLine($"internal {wrapperName}(global::TUnit.Mocks.IMockEngineAccess engine, int memberId, string memberName, global::TUnit.Mocks.Arguments.IArgumentMatcher[] matchers)");
            using (writer.Block())
            {
                writer.AppendLine("_engine = engine;");
                writer.AppendLine("_memberId = memberId;");
                writer.AppendLine("_memberName = memberName;");
                writer.AppendLine("_matchers = matchers;");
                using (writer.Block($"_lazyBuilder = new global::System.Lazy<{builderType}>(() =>"))
                {
                    writer.AppendLine("var setup = new global::TUnit.Mocks.Setup.MethodSetup(_memberId, _matchers, _memberName);");
                    writer.AppendLine("_engine.AddSetup(setup);");
                    writer.AppendLine($"return new {builderType}(setup);");
                }
                writer.AppendLine(");");
                writer.AppendLine("_ = _lazyBuilder.Value;");
            }

            writer.AppendLine();

            // EnsureSetup method
            writer.AppendLine($"private {builderType} EnsureSetup() => _lazyBuilder.Value;");

            writer.AppendLine();

            // Public self-returning setup methods
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws<TException>() where TException : global::System.Exception, new() {{ EnsureSetup().Throws<TException>(); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Exception exception) {{ EnsureSetup().Throws(exception); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action callback) {{ EnsureSetup().Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action<object?[]> callback) {{ EnsureSetup().Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Func<object?[], global::System.Exception> exceptionFactory) {{ EnsureSetup().Throws(exceptionFactory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Raises(string eventName, object? args = null) {{ EnsureSetup().Raises(eventName, args); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            if (hasOutRef)
                writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
            writer.AppendLine($"public {wrapperName} SetsOutParameter(int paramIndex, object? value) {{ EnsureSetup().SetsOutParameter(paramIndex, value); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} TransitionsTo(string stateName) {{ EnsureSetup().TransitionsTo(stateName); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Then() {{ EnsureSetup().Then(); return this; }}");

            // Typed parameter overloads (only for methods with typed params)
            if (nonOutParams.Count >= 1)
            {
                writer.AppendLine();
                GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName);
                writer.AppendLine();
                GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName);
            }

            // Typed out/ref parameter setters
            if (hasOutRef)
            {
                writer.AppendLine();
                GenerateTypedOutRefMethods(writer, allParameters, wrapperName);
            }

            // Typed event raises
            if (events.Length > 0)
            {
                writer.AppendLine();
                GenerateTypedEventRaises(writer, events, wrapperName);
            }

            // Verify methods (ICallVerification implementation)
            writer.AppendLine();
            writer.AppendLine("// ICallVerification");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled() => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled();");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(global::TUnit.Mocks.Times times) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(times);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(global::TUnit.Mocks.Times times, string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(times, message);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(message);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasNeverCalled() => _engine.CreateVerification(_memberId, _memberName, _matchers).WasNeverCalled();");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasNeverCalled(string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasNeverCalled(message);");
        }
    }

    private static void GenerateTypedReturnsOverload(CodeWriter writer, List<MockParameterModel> nonOutParams,
        string returnType, string wrapperName)
    {
        var typeList = string.Join(", ", nonOutParams.Select(p => p.FullyQualifiedType));
        var funcType = $"global::System.Func<{typeList}, {returnType}>";
        var castArgs = BuildCastArgs(nonOutParams);

        writer.AppendLine("/// <summary>Configure a typed computed return value using the actual method parameters.</summary>");
        using (writer.Block($"public {wrapperName} Returns({funcType} factory)"))
        {
            writer.AppendLine($"EnsureSetup().Returns(args => factory({castArgs}));");
            writer.AppendLine("return this;");
        }
    }

    private static void GenerateTypedCallbackOverload(CodeWriter writer, List<MockParameterModel> nonOutParams,
        string wrapperName)
    {
        var typeList = string.Join(", ", nonOutParams.Select(p => p.FullyQualifiedType));
        var actionType = $"global::System.Action<{typeList}>";
        var castArgs = BuildCastArgs(nonOutParams);

        writer.AppendLine("/// <summary>Execute a typed callback using the actual method parameters.</summary>");
        using (writer.Block($"public {wrapperName} Callback({actionType} callback)"))
        {
            writer.AppendLine($"EnsureSetup().Callback(args => callback({castArgs}));");
            writer.AppendLine("return this;");
        }
    }

    private static void GenerateTypedThrowsOverload(CodeWriter writer, List<MockParameterModel> nonOutParams,
        string wrapperName)
    {
        var typeList = string.Join(", ", nonOutParams.Select(p => p.FullyQualifiedType));
        var funcType = $"global::System.Func<{typeList}, global::System.Exception>";
        var castArgs = BuildCastArgs(nonOutParams);

        writer.AppendLine("/// <summary>Configure a typed computed exception using the actual method parameters.</summary>");
        using (writer.Block($"public {wrapperName} Throws({funcType} exceptionFactory)"))
        {
            writer.AppendLine($"EnsureSetup().Throws(args => exceptionFactory({castArgs}));");
            writer.AppendLine("return this;");
        }
    }

    private static void GenerateTypedEventRaises(CodeWriter writer, EquatableArray<MockEventModel> events,
        string wrapperName)
    {
        bool first = true;
        foreach (var evt in events)
        {
            if (!first) writer.AppendLine();
            first = false;

            var paramList = evt.RaiseParameterList.Length == 0
                ? ""
                : string.Join(", ", evt.RaiseParameterList.Select(p => $"{p.FullyQualifiedType} {p.Name}"));

            string argsExpr;
            if (evt.RaiseParameterList.Length == 0)
            {
                argsExpr = "";
            }
            else if (evt.RaiseParameterList.Length == 1)
            {
                argsExpr = $", (object?){evt.RaiseParameterList[0].Name}";
            }
            else
            {
                var argNames = string.Join(", ", evt.RaiseParameterList.Select(p => p.Name));
                argsExpr = $", (object?)new object?[] {{ {argNames} }}";
            }

            writer.AppendLine($"/// <summary>Auto-raise the {evt.Name} event when this method is called.</summary>");
            writer.AppendLine($"public {wrapperName} Raises{evt.Name}({paramList}) {{ EnsureSetup().Raises(\"{evt.Name}\"{argsExpr}); return this; }}");
        }
    }

    private static void GenerateTypedOutRefMethods(CodeWriter writer, EquatableArray<MockParameterModel> allParameters, string wrapperName)
    {
        for (int i = 0; i < allParameters.Length; i++)
        {
            var param = allParameters[i];
            if (param.Direction != ParameterDirection.Out && param.Direction != ParameterDirection.Ref)
                continue;

            var prefix = param.Direction == ParameterDirection.Out ? "SetsOut" : "SetsRef";
            var methodName = prefix + ToPascalCase(param.Name);
            var dirLabel = param.Direction == ParameterDirection.Out ? "out" : "ref";

            writer.AppendLine($"/// <summary>Sets the '{param.Name}' {dirLabel} parameter to the specified value when this setup matches.</summary>");
            writer.AppendLine($"public {wrapperName} {methodName}({param.FullyQualifiedType} {param.Name}) {{ EnsureSetup().SetsOutParameter({i}, {param.Name}); return this; }}");
        }
    }

    private static string ToPascalCase(string name)
        => string.IsNullOrEmpty(name) ? name : char.ToUpperInvariant(name[0]) + name[1..];

    private static string BuildCastArgs(List<MockParameterModel> nonOutParams)
    {
        return string.Join(", ", nonOutParams.Select((p, i) =>
            $"({p.FullyQualifiedType})args[{i}]!"));
    }

    private static void GenerateMemberMethod(CodeWriter writer, MockMemberModel method, MockTypeModel model, string safeName)
    {
        // For async methods (Task<T>/ValueTask<T>), unwrap the return type so users write .Returns(5) not .Returns(Task.FromResult(5))
        // For void-async methods (Task/ValueTask), IsVoid is already true
        var setupReturnType = method.IsAsync && !method.IsVoid
            ? method.UnwrappedReturnType
            : method.ReturnType;

        var hasEvents = model.Events.Length > 0;
        var useTypedWrapper = ShouldGenerateTypedWrapper(method, hasEvents);
        string returnType;

        if (useTypedWrapper)
        {
            returnType = GetWrapperName(safeName, method);
        }
        else if (method.IsVoid)
        {
            returnType = "global::TUnit.Mocks.VoidMockMethodCall";
        }
        else
        {
            returnType = $"global::TUnit.Mocks.MockMethodCall<{setupReturnType}>";
        }

        var paramList = GetArgParameterList(method);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        var safeMemberName = GetSafeMemberName(method.Name);
        var extensionParam = $"this global::TUnit.Mocks.Mock<{model.FullyQualifiedName}> mock";
        var fullParamList = string.IsNullOrEmpty(paramList) ? extensionParam : $"{extensionParam}, {paramList}";

        using (writer.Block($"public static {returnType} {safeMemberName}{typeParams}({fullParamList}){constraints}"))
        {
            // Build matchers array
            var nonOutParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();

            if (nonOutParams.Count == 0)
            {
                writer.AppendLine("var matchers = global::System.Array.Empty<global::TUnit.Mocks.Arguments.IArgumentMatcher>();");
            }
            else
            {
                var matcherArgs = string.Join(", ", nonOutParams.Select(p => $"{p.Name}.Matcher"));
                writer.AppendLine($"var matchers = new global::TUnit.Mocks.Arguments.IArgumentMatcher[] {{ {matcherArgs} }};");
            }

            if (useTypedWrapper)
            {
                var wrapperName = GetWrapperName(safeName, method);
                writer.AppendLine($"return new {wrapperName}(mock.Engine, {method.MemberId}, \"{method.Name}\", matchers);");
            }
            else if (method.IsVoid)
            {
                writer.AppendLine($"return new global::TUnit.Mocks.VoidMockMethodCall(mock.Engine, {method.MemberId}, \"{method.Name}\", matchers);");
            }
            else
            {
                writer.AppendLine($"return new global::TUnit.Mocks.MockMethodCall<{setupReturnType}>(mock.Engine, {method.MemberId}, \"{method.Name}\", matchers);");
            }
        }
    }

    private static void GeneratePropertyExtensionBlock(CodeWriter writer, List<MockMemberModel> props, MockTypeModel model, string safeName)
    {
        using (writer.Block($"extension(global::TUnit.Mocks.Mock<{model.FullyQualifiedName}> mock)"))
        {
            bool first = true;
            foreach (var prop in props)
            {
                if (!first) writer.AppendLine();
                first = false;

                var getterMemberId = prop.HasGetter ? prop.MemberId.ToString() : "0";
                var setterMemberId = prop.HasSetter ? prop.SetterMemberId.ToString() : "0";
                var hasGetter = prop.HasGetter ? "true" : "false";
                var hasSetter = prop.HasSetter ? "true" : "false";

                var safePropName = GetSafeMemberName(prop.Name);

                writer.AppendLine($"public global::TUnit.Mocks.PropertyMockCall<{prop.ReturnType}> {safePropName}");
                writer.AppendLine($"    => new(mock.Engine, {getterMemberId}, {setterMemberId}, \"{prop.Name}\", {hasGetter}, {hasSetter});");
            }
        }
    }

    private static void GenerateRaiseExtensionMethods(CodeWriter writer, MockTypeModel model)
    {
        bool first = true;
        foreach (var evt in model.Events)
        {
            if (!first) writer.AppendLine();
            first = false;

            var extensionParam = $"this global::TUnit.Mocks.Mock<{model.FullyQualifiedName}> mock";

            var raiseParamStr = evt.RaiseParameterList.Length == 0
                ? ""
                : string.Join(", ", evt.RaiseParameterList.Select(p => $"{p.FullyQualifiedType} {p.Name}"));
            var raiseParams = string.IsNullOrEmpty(raiseParamStr)
                ? extensionParam
                : $"{extensionParam}, {raiseParamStr}";

            string argsExpr;
            if (evt.RaiseParameterList.Length == 0)
            {
                argsExpr = "null";
            }
            else if (evt.RaiseParameterList.Length == 1)
            {
                argsExpr = $"(object?){evt.RaiseParameterList[0].Name}";
            }
            else
            {
                var paramNames = string.Join(", ", evt.RaiseParameterList.Select(p => p.Name));
                argsExpr = $"(object?)new object?[] {{ {paramNames} }}";
            }

            using (writer.Block($"public static void Raise{evt.Name}({raiseParams})"))
            {
                writer.AppendLine($"((global::TUnit.Mocks.IRaisable)mock.Engine.Raisable!).RaiseEvent(\"{evt.Name}\", {argsExpr});");
            }
        }
    }

    private static string GetArgParameterList(MockMemberModel method)
    {
        // Only include non-out parameters as Arg<T> in setup
        return string.Join(", ", method.Parameters
            .Where(p => p.Direction != ParameterDirection.Out)
            .Select(p => $"global::TUnit.Mocks.Arguments.Arg<{p.FullyQualifiedType}> {p.Name}"));
    }

    private static string GetTypeParameterList(MockMemberModel method)
    {
        if (method.TypeParameters.Length == 0) return "";
        return "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";
    }

    private static string GetConstraintClauses(MockMemberModel method)
    {
        var clauses = new List<string>();
        foreach (var tp in method.TypeParameters)
        {
            if (!string.IsNullOrEmpty(tp.Constraints))
            {
                clauses.Add($"where {tp.Name} : {tp.Constraints}");
            }
        }
        return clauses.Count > 0 ? " " + string.Join(" ", clauses) : "";
    }
}
