using System.Collections.Generic;
using System.Linq;
using TUnit.Mocks.SourceGenerator.Models;

namespace TUnit.Mocks.SourceGenerator.Builders;

/// <summary>
/// Generates a single _MockMembers.g.cs file per mocked type, containing:
/// 1. Extension methods on Mock&lt;T&gt; for each method
/// 2. Extension properties on Mock&lt;T&gt; for each property (C# 14 extension blocks)
/// 3. Unified sealed classes per qualifying method (with BOTH setup and verify methods)
/// </summary>
internal static class MockMembersBuilder
{
    private const int MaxTypedParams = 8;
    private const int MaxFuncOverloadParams = 4;

    private static readonly HashSet<string> MockMemberNames = new(System.StringComparer.Ordinal)
    {
        "Object",
        "GetHashCode", "GetType", "ToString", "Equals"
    };

    public static string Build(MockTypeModel model)
    {
        var writer = new CodeWriter();
        var safeName = MockImplBuilder.GetSafeName(model.FullyQualifiedName);
        var hasEvents = model.Events.Length > 0;

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();

        using (writer.Block("namespace TUnit.Mocks.Generated"))
        {
            // Extension methods class
            using (writer.Block($"public static class {safeName}_MockMemberExtensions"))
            {
                bool firstMember = true;

                // Methods
                foreach (var method in model.Methods)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GenerateMemberMethod(writer, method, model, safeName);
                }

                // Properties -- extension properties via C# 14 extension blocks
                // (skip ref struct properties — can't use PropertyMockCall<RefStruct>)
                var memberProps = model.Properties
                    .Where(p => !p.IsIndexer && !p.IsRefStructReturn && (p.HasGetter || p.HasSetter))
                    .ToList();
                if (memberProps.Count > 0)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GeneratePropertyExtensionBlock(writer, memberProps, model, safeName);
                }

                // Raise extension methods for events
                if (model.Events.Length > 0)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GenerateRaiseExtensionMethods(writer, model);
                }
            }

            // Generate unified sealed classes for qualifying methods
            foreach (var method in model.Methods)
            {
                if (!ShouldGenerateTypedWrapper(method, hasEvents)) continue;
                writer.AppendLine();
                GenerateUnifiedSealedClass(writer, method, safeName, model.Events);
            }
        }

        return writer.ToString();
    }

    private static bool ShouldGenerateTypedWrapper(MockMemberModel method, bool hasEvents)
    {
        if (method.IsGenericMethod) return false;

        // Exclude out params and ref struct params (can't be boxed or used as type args)
        var matchableParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out && !p.IsRefStruct).ToList();
        if (matchableParams.Count == 0)
        {
            // Include span-type ref struct out/ref params (supported via array conversion)
            var hasOutRefParams = method.Parameters.Any(p =>
                (!p.IsRefStruct || p.SpanElementType is not null) &&
                (p.Direction == ParameterDirection.Out || p.Direction == ParameterDirection.Ref));
            // Span return types need a typed wrapper for the generated Returns(SpanType) method
            var hasSpanReturn = method.SpanReturnElementType is not null;
            return hasEvents || hasOutRefParams || hasSpanReturn;
        }
        return matchableParams.Count <= MaxTypedParams;
    }

    private static string GetWrapperName(string safeName, MockMemberModel method)
        => $"{safeName}_{method.Name}_M{method.MemberId}_MockCall";

    private static string GetSafeMemberName(string name)
        => MockMemberNames.Contains(name) ? name + "_" : name;

    private static void GenerateUnifiedSealedClass(CodeWriter writer, MockMemberModel method, string safeName,
        EquatableArray<MockEventModel> events)
    {
        var setupReturnType = method.IsAsync && !method.IsVoid
            ? method.UnwrappedReturnType
            : method.ReturnType;

        var wrapperName = GetWrapperName(safeName, method);
        var matchableParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out && !p.IsRefStruct).ToList();
        var hasRefStructParams = method.HasRefStructParams;
        var allNonOutParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();

        // Ref struct returns use the void wrapper (can't use generic type args with ref structs)
        if (method.IsVoid || method.IsRefStructReturn)
        {
            GenerateVoidUnifiedClass(writer, wrapperName, matchableParams, events, method.Parameters, hasRefStructParams, allNonOutParams, method.SpanReturnElementType, method.ReturnType);
        }
        else
        {
            GenerateReturnUnifiedClass(writer, wrapperName, matchableParams, setupReturnType, events, method.Parameters, hasRefStructParams, allNonOutParams);
        }
    }

    private static void GenerateReturnUnifiedClass(CodeWriter writer, string wrapperName,
        List<MockParameterModel> nonOutParams, string returnType, EquatableArray<MockEventModel> events,
        EquatableArray<MockParameterModel> allParameters, bool hasRefStructParams, List<MockParameterModel> allNonOutParams)
    {
        var builderType = $"global::TUnit.Mocks.Setup.MethodSetupBuilder<{returnType}>";
        var hasOutRef = allParameters.Any(p => p.Direction == ParameterDirection.Out || p.Direction == ParameterDirection.Ref);

        writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        using (writer.Block($"public sealed class {wrapperName} : global::TUnit.Mocks.Verification.ICallVerification"))
        {
            // Fields
            writer.AppendLine("private readonly global::TUnit.Mocks.IMockEngineAccess _engine;");
            writer.AppendLine("private readonly int _memberId;");
            writer.AppendLine("private readonly string _memberName;");
            writer.AppendLine("private readonly global::TUnit.Mocks.Arguments.IArgumentMatcher[] _matchers;");
            writer.AppendLine($"private readonly global::System.Lazy<{builderType}> _lazyBuilder;");
            writer.AppendLine();

            // Constructor — lazy registration via Lazy<T> for thread safety
            writer.AppendLine($"internal {wrapperName}(global::TUnit.Mocks.IMockEngineAccess engine, int memberId, string memberName, global::TUnit.Mocks.Arguments.IArgumentMatcher[] matchers)");
            using (writer.Block())
            {
                writer.AppendLine("_engine = engine;");
                writer.AppendLine("_memberId = memberId;");
                writer.AppendLine("_memberName = memberName;");
                writer.AppendLine("_matchers = matchers;");
                using (writer.Block($"_lazyBuilder = new global::System.Lazy<{builderType}>(() =>"))
                {
                    writer.AppendLine("var setup = new global::TUnit.Mocks.Setup.MethodSetup(_memberId, _matchers, _memberName);");
                    writer.AppendLine("_engine.AddSetup(setup);");
                    writer.AppendLine($"return new {builderType}(setup);");
                }
                writer.AppendLine(");");
            }

            writer.AppendLine();

            // EnsureSetup method
            writer.AppendLine($"private {builderType} EnsureSetup() => _lazyBuilder.Value;");

            writer.AppendLine();

            // Public self-returning setup methods
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Returns({returnType} value) {{ EnsureSetup().Returns(value); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Returns(global::System.Func<{returnType}> factory) {{ EnsureSetup().Returns(factory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} ReturnsSequentially(params {returnType}[] values) {{ EnsureSetup().ReturnsSequentially(values); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws<TException>() where TException : global::System.Exception, new() {{ EnsureSetup().Throws<TException>(); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Exception exception) {{ EnsureSetup().Throws(exception); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action callback) {{ EnsureSetup().Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action<object?[]> callback) {{ EnsureSetup().Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Returns(global::System.Func<object?[], {returnType}> factory) {{ EnsureSetup().Returns(factory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Func<object?[], global::System.Exception> exceptionFactory) {{ EnsureSetup().Throws(exceptionFactory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Raises(string eventName, object? args = null) {{ EnsureSetup().Raises(eventName, args); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            if (hasOutRef)
                writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
            writer.AppendLine($"public {wrapperName} SetsOutParameter(int paramIndex, object? value) {{ EnsureSetup().SetsOutParameter(paramIndex, value); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} TransitionsTo(string stateName) {{ EnsureSetup().TransitionsTo(stateName); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Then() {{ EnsureSetup().Then(); return this; }}");

            // Typed parameter overloads (only for methods with typed params)
            if (nonOutParams.Count >= 1)
            {
                writer.AppendLine();
                if (hasRefStructParams)
                {
                    writer.AppendLine("#if NET9_0_OR_GREATER");
                    GenerateTypedReturnsOverload(writer, nonOutParams, returnType, wrapperName, allNonOutParams);
                    writer.AppendLine();
                    GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName, allNonOutParams);
                    writer.AppendLine();
                    GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName, allNonOutParams);
                    writer.AppendLine("#else");
                    GenerateTypedReturnsOverload(writer, nonOutParams, returnType, wrapperName);
                    writer.AppendLine();
                    GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName);
                    writer.AppendLine();
                    GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName);
                    writer.AppendLine("#endif");
                }
                else
                {
                    GenerateTypedReturnsOverload(writer, nonOutParams, returnType, wrapperName);
                    writer.AppendLine();
                    GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName);
                    writer.AppendLine();
                    GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName);
                }
            }

            // Typed out/ref parameter setters
            if (hasOutRef)
            {
                writer.AppendLine();
                GenerateTypedOutRefMethods(writer, allParameters, wrapperName);
            }

            // Typed event raises
            if (events.Length > 0)
            {
                writer.AppendLine();
                GenerateTypedEventRaises(writer, events, wrapperName);
            }

            // Verify methods (ICallVerification implementation)
            writer.AppendLine();
            writer.AppendLine("// ICallVerification");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled() => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled();");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(global::TUnit.Mocks.Times times) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(times);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(global::TUnit.Mocks.Times times, string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(times, message);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(message);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasNeverCalled() => _engine.CreateVerification(_memberId, _memberName, _matchers).WasNeverCalled();");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasNeverCalled(string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasNeverCalled(message);");
        }
    }

    private static void GenerateVoidUnifiedClass(CodeWriter writer, string wrapperName,
        List<MockParameterModel> nonOutParams, EquatableArray<MockEventModel> events,
        EquatableArray<MockParameterModel> allParameters, bool hasRefStructParams, List<MockParameterModel> allNonOutParams,
        string? spanReturnElementType = null, string? spanReturnType = null)
    {
        var builderType = "global::TUnit.Mocks.Setup.VoidMethodSetupBuilder";
        var hasOutRef = allParameters.Any(p => p.Direction == ParameterDirection.Out || p.Direction == ParameterDirection.Ref);

        writer.AppendLine($"[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        using (writer.Block($"public sealed class {wrapperName} : global::TUnit.Mocks.Verification.ICallVerification"))
        {
            // Fields
            writer.AppendLine("private readonly global::TUnit.Mocks.IMockEngineAccess _engine;");
            writer.AppendLine("private readonly int _memberId;");
            writer.AppendLine("private readonly string _memberName;");
            writer.AppendLine("private readonly global::TUnit.Mocks.Arguments.IArgumentMatcher[] _matchers;");
            writer.AppendLine($"private readonly global::System.Lazy<{builderType}> _lazyBuilder;");
            writer.AppendLine();

            // Constructor — Lazy<T> for thread safety, eagerly materialized because void methods
            // are commonly used without chaining (e.g., mock.Log(Arg.Any<string>()) in strict mode).
            writer.AppendLine($"internal {wrapperName}(global::TUnit.Mocks.IMockEngineAccess engine, int memberId, string memberName, global::TUnit.Mocks.Arguments.IArgumentMatcher[] matchers)");
            using (writer.Block())
            {
                writer.AppendLine("_engine = engine;");
                writer.AppendLine("_memberId = memberId;");
                writer.AppendLine("_memberName = memberName;");
                writer.AppendLine("_matchers = matchers;");
                using (writer.Block($"_lazyBuilder = new global::System.Lazy<{builderType}>(() =>"))
                {
                    writer.AppendLine("var setup = new global::TUnit.Mocks.Setup.MethodSetup(_memberId, _matchers, _memberName);");
                    writer.AppendLine("_engine.AddSetup(setup);");
                    writer.AppendLine($"return new {builderType}(setup);");
                }
                writer.AppendLine(");");
                writer.AppendLine("_ = _lazyBuilder.Value;");
            }

            writer.AppendLine();

            // EnsureSetup method
            writer.AppendLine($"private {builderType} EnsureSetup() => _lazyBuilder.Value;");

            writer.AppendLine();

            // Public self-returning setup methods
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws<TException>() where TException : global::System.Exception, new() {{ EnsureSetup().Throws<TException>(); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Exception exception) {{ EnsureSetup().Throws(exception); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action callback) {{ EnsureSetup().Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action<object?[]> callback) {{ EnsureSetup().Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Func<object?[], global::System.Exception> exceptionFactory) {{ EnsureSetup().Throws(exceptionFactory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Raises(string eventName, object? args = null) {{ EnsureSetup().Raises(eventName, args); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            if (hasOutRef)
                writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
            writer.AppendLine($"public {wrapperName} SetsOutParameter(int paramIndex, object? value) {{ EnsureSetup().SetsOutParameter(paramIndex, value); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} TransitionsTo(string stateName) {{ EnsureSetup().TransitionsTo(stateName); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Then() {{ EnsureSetup().Then(); return this; }}");

            // Span return support: generate Returns(SpanType) that stores via SetsOutParameter(-1, ...)
            if (spanReturnElementType is not null && spanReturnType is not null)
            {
                writer.AppendLine();
                writer.AppendLine($"/// <summary>Configure the return value for this span-returning method.</summary>");
                writer.AppendLine($"public {wrapperName} Returns({spanReturnType} value) {{ EnsureSetup().SetsOutParameter(global::TUnit.Mocks.Setup.OutRefContext.SpanReturnValueIndex, value.ToArray()); return this; }}");
            }

            // Typed parameter overloads (only for methods with typed params)
            if (nonOutParams.Count >= 1)
            {
                writer.AppendLine();
                if (hasRefStructParams)
                {
                    writer.AppendLine("#if NET9_0_OR_GREATER");
                    GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName, allNonOutParams);
                    writer.AppendLine();
                    GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName, allNonOutParams);
                    writer.AppendLine("#else");
                    GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName);
                    writer.AppendLine();
                    GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName);
                    writer.AppendLine("#endif");
                }
                else
                {
                    GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName);
                    writer.AppendLine();
                    GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName);
                }
            }

            // Typed out/ref parameter setters
            if (hasOutRef)
            {
                writer.AppendLine();
                GenerateTypedOutRefMethods(writer, allParameters, wrapperName);
            }

            // Typed event raises
            if (events.Length > 0)
            {
                writer.AppendLine();
                GenerateTypedEventRaises(writer, events, wrapperName);
            }

            // Verify methods (ICallVerification implementation)
            writer.AppendLine();
            writer.AppendLine("// ICallVerification");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled() => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled();");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(global::TUnit.Mocks.Times times) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(times);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(global::TUnit.Mocks.Times times, string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(times, message);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasCalled(string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasCalled(message);");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasNeverCalled() => _engine.CreateVerification(_memberId, _memberName, _matchers).WasNeverCalled();");
            writer.AppendLine("/// <inheritdoc />");
            writer.AppendLine("public void WasNeverCalled(string? message) => _engine.CreateVerification(_memberId, _memberName, _matchers).WasNeverCalled(message);");
        }
    }

    private static void GenerateTypedReturnsOverload(CodeWriter writer, List<MockParameterModel> nonOutParams,
        string returnType, string wrapperName, List<MockParameterModel>? allNonOutParams = null)
    {
        var typeList = string.Join(", ", nonOutParams.Select(p => p.FullyQualifiedType));
        var funcType = $"global::System.Func<{typeList}, {returnType}>";
        var castArgs = BuildCastArgs(nonOutParams, allNonOutParams);

        writer.AppendLine("/// <summary>Configure a typed computed return value using the actual method parameters.</summary>");
        using (writer.Block($"public {wrapperName} Returns({funcType} factory)"))
        {
            writer.AppendLine($"EnsureSetup().Returns(args => factory({castArgs}));");
            writer.AppendLine("return this;");
        }
    }

    private static void GenerateTypedCallbackOverload(CodeWriter writer, List<MockParameterModel> nonOutParams,
        string wrapperName, List<MockParameterModel>? allNonOutParams = null)
    {
        var typeList = string.Join(", ", nonOutParams.Select(p => p.FullyQualifiedType));
        var actionType = $"global::System.Action<{typeList}>";
        var castArgs = BuildCastArgs(nonOutParams, allNonOutParams);

        writer.AppendLine("/// <summary>Execute a typed callback using the actual method parameters.</summary>");
        using (writer.Block($"public {wrapperName} Callback({actionType} callback)"))
        {
            writer.AppendLine($"EnsureSetup().Callback(args => callback({castArgs}));");
            writer.AppendLine("return this;");
        }
    }

    private static void GenerateTypedThrowsOverload(CodeWriter writer, List<MockParameterModel> nonOutParams,
        string wrapperName, List<MockParameterModel>? allNonOutParams = null)
    {
        var typeList = string.Join(", ", nonOutParams.Select(p => p.FullyQualifiedType));
        var funcType = $"global::System.Func<{typeList}, global::System.Exception>";
        var castArgs = BuildCastArgs(nonOutParams, allNonOutParams);

        writer.AppendLine("/// <summary>Configure a typed computed exception using the actual method parameters.</summary>");
        using (writer.Block($"public {wrapperName} Throws({funcType} exceptionFactory)"))
        {
            writer.AppendLine($"EnsureSetup().Throws(args => exceptionFactory({castArgs}));");
            writer.AppendLine("return this;");
        }
    }

    private static void GenerateTypedEventRaises(CodeWriter writer, EquatableArray<MockEventModel> events,
        string wrapperName)
    {
        bool first = true;
        foreach (var evt in events)
        {
            if (!first) writer.AppendLine();
            first = false;

            var paramList = evt.RaiseParameterList.Length == 0
                ? ""
                : string.Join(", ", evt.RaiseParameterList.Select(p => $"{p.FullyQualifiedType} {p.Name}"));

            string argsExpr;
            if (evt.RaiseParameterList.Length == 0)
            {
                argsExpr = "";
            }
            else if (evt.RaiseParameterList.Length == 1)
            {
                argsExpr = $", (object?){evt.RaiseParameterList[0].Name}";
            }
            else
            {
                var argNames = string.Join(", ", evt.RaiseParameterList.Select(p => p.Name));
                argsExpr = $", (object?)new object?[] {{ {argNames} }}";
            }

            writer.AppendLine($"/// <summary>Auto-raise the {evt.Name} event when this method is called.</summary>");
            writer.AppendLine($"public {wrapperName} Raises{evt.Name}({paramList}) {{ EnsureSetup().Raises(\"{evt.Name}\"{argsExpr}); return this; }}");
        }
    }

    private static void GenerateTypedOutRefMethods(CodeWriter writer, EquatableArray<MockParameterModel> allParameters, string wrapperName)
    {
        for (int i = 0; i < allParameters.Length; i++)
        {
            var param = allParameters[i];
            if (param.Direction != ParameterDirection.Out && param.Direction != ParameterDirection.Ref)
                continue;

            // Skip non-span ref structs (can't be boxed)
            if (param.IsRefStruct && param.SpanElementType is null)
                continue;

            var prefix = param.Direction == ParameterDirection.Out ? "SetsOut" : "SetsRef";
            var methodName = prefix + ToPascalCase(param.Name);
            var dirLabel = param.Direction == ParameterDirection.Out ? "out" : "ref";

            writer.AppendLine($"/// <summary>Sets the '{param.Name}' {dirLabel} parameter to the specified value when this setup matches.</summary>");
            if (param.SpanElementType is not null)
            {
                // Span types: convert to array for storage, reconstruct at invocation time
                writer.AppendLine($"public {wrapperName} {methodName}({param.FullyQualifiedType} {param.Name}) {{ EnsureSetup().SetsOutParameter({i}, {param.Name}.ToArray()); return this; }}");
            }
            else
            {
                writer.AppendLine($"public {wrapperName} {methodName}({param.FullyQualifiedType} {param.Name}) {{ EnsureSetup().SetsOutParameter({i}, {param.Name}); return this; }}");
            }
        }
    }

    private static string ToPascalCase(string name)
        => string.IsNullOrEmpty(name) ? name : char.ToUpperInvariant(name[0]) + name[1..];

    private static string BuildCastArgs(List<MockParameterModel> nonOutParams, List<MockParameterModel>? allNonOutParams = null)
    {
        if (allNonOutParams is null)
            return string.Join(", ", nonOutParams.Select((p, i) => $"({p.FullyQualifiedType})args[{i}]!"));

        var indexMap = allNonOutParams.Select((p, i) => (p, i)).ToDictionary(x => x.p, x => x.i);
        return string.Join(", ", nonOutParams.Select(p => $"({p.FullyQualifiedType})args[{indexMap[p]}]!"));
    }

    private static void GenerateMemberMethod(CodeWriter writer, MockMemberModel method, MockTypeModel model, string safeName)
    {
        if (method.HasRefStructParams)
        {
            writer.AppendLine("#if NET9_0_OR_GREATER");
            EmitMemberMethodBody(writer, method, model, safeName, includeRefStructArgs: true);
            EmitFuncOverloads(writer, method, model, safeName, includeRefStructArgs: true);
            writer.AppendLine("#else");
            EmitMemberMethodBody(writer, method, model, safeName, includeRefStructArgs: false);
            EmitFuncOverloads(writer, method, model, safeName, includeRefStructArgs: false);
            writer.AppendLine("#endif");
        }
        else
        {
            EmitMemberMethodBody(writer, method, model, safeName, includeRefStructArgs: false);
            EmitFuncOverloads(writer, method, model, safeName, includeRefStructArgs: false);
        }
    }

    private static (bool UseTypedWrapper, string ReturnType, string SetupReturnType) GetReturnTypeInfo(
        MockMemberModel method, MockTypeModel model, string safeName)
    {
        var setupReturnType = method.IsAsync && !method.IsVoid
            ? method.UnwrappedReturnType
            : method.ReturnType;

        var hasEvents = model.Events.Length > 0;
        var useTypedWrapper = ShouldGenerateTypedWrapper(method, hasEvents);

        string returnType;
        if (useTypedWrapper)
            returnType = GetWrapperName(safeName, method);
        else if (method.IsVoid || method.IsRefStructReturn)
            returnType = "global::TUnit.Mocks.VoidMockMethodCall";
        else
            returnType = $"global::TUnit.Mocks.MockMethodCall<{setupReturnType}>";

        return (useTypedWrapper, returnType, setupReturnType);
    }

    private static void EmitMemberMethodBody(CodeWriter writer, MockMemberModel method, MockTypeModel model, string safeName, bool includeRefStructArgs)
    {
        var (useTypedWrapper, returnType, setupReturnType) = GetReturnTypeInfo(method, model, safeName);

        var paramList = GetArgParameterList(method, includeRefStructArgs);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        var safeMemberName = GetSafeMemberName(method.Name);
        var extensionParam = $"this global::TUnit.Mocks.Mock<{model.FullyQualifiedName}> mock";
        var fullParamList = string.IsNullOrEmpty(paramList) ? extensionParam : $"{extensionParam}, {paramList}";

        using (writer.Block($"public static {returnType} {safeMemberName}{typeParams}({fullParamList}){constraints}"))
        {
            // Build matchers array
            var matchableParams = includeRefStructArgs
                ? method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList()
                : method.Parameters.Where(p => p.Direction != ParameterDirection.Out && !p.IsRefStruct).ToList();

            if (matchableParams.Count == 0)
            {
                writer.AppendLine("var matchers = global::System.Array.Empty<global::TUnit.Mocks.Arguments.IArgumentMatcher>();");
            }
            else
            {
                var matcherArgs = string.Join(", ", matchableParams.Select(p => $"{p.Name}.Matcher"));
                writer.AppendLine($"var matchers = new global::TUnit.Mocks.Arguments.IArgumentMatcher[] {{ {matcherArgs} }};");
            }

            if (useTypedWrapper)
            {
                var wrapperName = GetWrapperName(safeName, method);
                writer.AppendLine($"return new {wrapperName}(global::TUnit.Mocks.Mock.GetEngine(mock), {method.MemberId}, \"{method.Name}\", matchers);");
            }
            else if (method.IsVoid || method.IsRefStructReturn)
            {
                writer.AppendLine($"return new global::TUnit.Mocks.VoidMockMethodCall(global::TUnit.Mocks.Mock.GetEngine(mock), {method.MemberId}, \"{method.Name}\", matchers);");
            }
            else
            {
                writer.AppendLine($"return new global::TUnit.Mocks.MockMethodCall<{setupReturnType}>(global::TUnit.Mocks.Mock.GetEngine(mock), {method.MemberId}, \"{method.Name}\", matchers);");
            }
        }
    }

    private static List<int> GetFuncEligibleParamIndices(MockMemberModel method)
    {
        var indices = new List<int>();
        for (int i = 0; i < method.Parameters.Length; i++)
        {
            var p = method.Parameters[i];
            if ((p.Direction == ParameterDirection.In || p.Direction == ParameterDirection.In_Readonly)
                && !p.IsRefStruct)
            {
                indices.Add(i);
            }
        }
        return indices;
    }

    private static void EmitFuncOverloads(CodeWriter writer, MockMemberModel method, MockTypeModel model,
        string safeName, bool includeRefStructArgs)
    {
        var eligible = GetFuncEligibleParamIndices(method);
        if (eligible.Count == 0 || eligible.Count > MaxFuncOverloadParams) return;

        int totalMasks = (1 << eligible.Count) - 1;
        for (int mask = 1; mask <= totalMasks; mask++)
        {
            writer.AppendLine();
            EmitSingleFuncOverload(writer, method, model, safeName, eligible, mask, includeRefStructArgs);
        }
    }

    private static void EmitSingleFuncOverload(CodeWriter writer, MockMemberModel method, MockTypeModel model,
        string safeName, List<int> eligibleIndices, int funcMask, bool includeRefStructArgs)
    {
        // Determine which parameter indices use Func<T, bool>
        var funcIndices = new HashSet<int>();
        for (int bit = 0; bit < eligibleIndices.Count; bit++)
        {
            if ((funcMask & (1 << bit)) != 0)
                funcIndices.Add(eligibleIndices[bit]);
        }

        var (useTypedWrapper, returnType, setupReturnType) = GetReturnTypeInfo(method, model, safeName);

        // Build mixed parameter list
        var paramParts = new List<string>();
        for (int i = 0; i < method.Parameters.Length; i++)
        {
            var p = method.Parameters[i];
            if (p.Direction == ParameterDirection.Out) continue;

            if (funcIndices.Contains(i))
            {
                paramParts.Add($"global::System.Func<{p.FullyQualifiedType}, bool> {p.Name}");
            }
            else if (p.IsRefStruct)
            {
                if (includeRefStructArgs)
                    paramParts.Add($"global::TUnit.Mocks.Arguments.RefStructArg<{p.FullyQualifiedType}> {p.Name}");
            }
            else
            {
                paramParts.Add($"global::TUnit.Mocks.Arguments.Arg<{p.FullyQualifiedType}> {p.Name}");
            }
        }

        var paramList = string.Join(", ", paramParts);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        var safeMemberName = GetSafeMemberName(method.Name);
        var extensionParam = $"this global::TUnit.Mocks.Mock<{model.FullyQualifiedName}> mock";
        var fullParamList = string.IsNullOrEmpty(paramList) ? extensionParam : $"{extensionParam}, {paramList}";

        using (writer.Block($"public static {returnType} {safeMemberName}{typeParams}({fullParamList}){constraints}"))
        {
            // Convert Func params to Arg<T> via implicit conversion
            foreach (var idx in funcIndices.OrderBy(i => i))
            {
                var p = method.Parameters[idx];
                writer.AppendLine($"global::TUnit.Mocks.Arguments.Arg<{p.FullyQualifiedType}> __fa_{p.Name} = {p.Name};");
            }

            // Build matchers array
            var matcherExprs = new List<string>();
            for (int i = 0; i < method.Parameters.Length; i++)
            {
                var p = method.Parameters[i];
                if (p.Direction == ParameterDirection.Out) continue;
                if (!includeRefStructArgs && p.IsRefStruct) continue;

                matcherExprs.Add(funcIndices.Contains(i) ? $"__fa_{p.Name}.Matcher" : $"{p.Name}.Matcher");
            }

            if (matcherExprs.Count == 0)
            {
                writer.AppendLine("var matchers = global::System.Array.Empty<global::TUnit.Mocks.Arguments.IArgumentMatcher>();");
            }
            else
            {
                writer.AppendLine($"var matchers = new global::TUnit.Mocks.Arguments.IArgumentMatcher[] {{ {string.Join(", ", matcherExprs)} }};");
            }

            // Return statement
            if (useTypedWrapper)
            {
                var wrapperName = GetWrapperName(safeName, method);
                writer.AppendLine($"return new {wrapperName}(global::TUnit.Mocks.Mock.GetEngine(mock), {method.MemberId}, \"{method.Name}\", matchers);");
            }
            else if (method.IsVoid || method.IsRefStructReturn)
            {
                writer.AppendLine($"return new global::TUnit.Mocks.VoidMockMethodCall(global::TUnit.Mocks.Mock.GetEngine(mock), {method.MemberId}, \"{method.Name}\", matchers);");
            }
            else
            {
                writer.AppendLine($"return new global::TUnit.Mocks.MockMethodCall<{setupReturnType}>(global::TUnit.Mocks.Mock.GetEngine(mock), {method.MemberId}, \"{method.Name}\", matchers);");
            }
        }
    }

    private static void GeneratePropertyExtensionBlock(CodeWriter writer, List<MockMemberModel> props, MockTypeModel model, string safeName)
    {
        using (writer.Block($"extension(global::TUnit.Mocks.Mock<{model.FullyQualifiedName}> mock)"))
        {
            bool first = true;
            foreach (var prop in props)
            {
                if (!first) writer.AppendLine();
                first = false;

                var getterMemberId = prop.HasGetter ? prop.MemberId.ToString() : "0";
                var setterMemberId = prop.HasSetter ? prop.SetterMemberId.ToString() : "0";
                var hasGetter = prop.HasGetter ? "true" : "false";
                var hasSetter = prop.HasSetter ? "true" : "false";

                var safePropName = GetSafeMemberName(prop.Name);

                writer.AppendLine($"public global::TUnit.Mocks.PropertyMockCall<{prop.ReturnType}> {safePropName}");
                writer.AppendLine($"    => new(global::TUnit.Mocks.Mock.GetEngine(mock), {getterMemberId}, {setterMemberId}, \"{prop.Name}\", {hasGetter}, {hasSetter});");
            }
        }
    }

    private static void GenerateRaiseExtensionMethods(CodeWriter writer, MockTypeModel model)
    {
        bool first = true;
        foreach (var evt in model.Events)
        {
            if (!first) writer.AppendLine();
            first = false;

            var extensionParam = $"this global::TUnit.Mocks.Mock<{model.FullyQualifiedName}> mock";

            var raiseParamStr = evt.RaiseParameterList.Length == 0
                ? ""
                : string.Join(", ", evt.RaiseParameterList.Select(p => $"{p.FullyQualifiedType} {p.Name}"));
            var raiseParams = string.IsNullOrEmpty(raiseParamStr)
                ? extensionParam
                : $"{extensionParam}, {raiseParamStr}";

            string argsExpr;
            if (evt.RaiseParameterList.Length == 0)
            {
                argsExpr = "null";
            }
            else if (evt.RaiseParameterList.Length == 1)
            {
                argsExpr = $"(object?){evt.RaiseParameterList[0].Name}";
            }
            else
            {
                var paramNames = string.Join(", ", evt.RaiseParameterList.Select(p => p.Name));
                argsExpr = $"(object?)new object?[] {{ {paramNames} }}";
            }

            using (writer.Block($"public static void Raise{evt.Name}({raiseParams})"))
            {
                writer.AppendLine($"((global::TUnit.Mocks.IRaisable)global::TUnit.Mocks.Mock.GetEngine(mock).Raisable!).RaiseEvent(\"{evt.Name}\", {argsExpr});");
            }
        }
    }

    private static string GetArgParameterList(MockMemberModel method, bool includeRefStructArgs)
    {
        var parts = new List<string>();
        foreach (var p in method.Parameters)
        {
            if (p.Direction == ParameterDirection.Out) continue;
            if (p.IsRefStruct)
            {
                if (includeRefStructArgs)
                    parts.Add($"global::TUnit.Mocks.Arguments.RefStructArg<{p.FullyQualifiedType}> {p.Name}");
            }
            else
            {
                parts.Add($"global::TUnit.Mocks.Arguments.Arg<{p.FullyQualifiedType}> {p.Name}");
            }
        }
        return string.Join(", ", parts);
    }

    private static string GetTypeParameterList(MockMemberModel method)
    {
        if (method.TypeParameters.Length == 0) return "";
        return "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";
    }

    private static string GetConstraintClauses(MockMemberModel method)
    {
        var clauses = new List<string>();
        foreach (var tp in method.TypeParameters)
        {
            if (!string.IsNullOrEmpty(tp.Constraints))
            {
                clauses.Add($"where {tp.Name} : {tp.Constraints}");
            }
        }
        return clauses.Count > 0 ? " " + string.Join(" ", clauses) : "";
    }
}
